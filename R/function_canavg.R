#' Compute coefficients for weighted averaging of multiple canopy densiometer readings taken at a single point on the ground surface.
#'
#'-----------------------------------------------
#'
#'PACKAGE OVERVIEW
#'
#' `canavg` (contraction of 'canopy average') is principally used to compute coefficients for the weighted averaging of multiple forest canopy cover measurements taken from a single point using a concave spherical mirror canopy densiometer. This is accomplished in four sequential steps.
#'
#'> Step 1: Calculate the spherical coordinates of points in the sky corresponding to each point on the mirror surface when facing in every direction in which measurements were taken (e.g., there are 96 points on the mirror surface, so there are 96*4 or 384 sky points between N-, E-, S-, and W-facing measurements). These coordinates are expressed in degrees clockwise from due north (azimuth) and degrees above horizontal (altitude). Essentially, these sky points represent points in the sky from which light must originate in order to reflect off the mirror surface at a given point in the correct direction to enter the observer's eye.
#'
#'> Step 2: Associate each of these sky points with a single insolation value, computed externally using the Gap Light Analyzer (GLA) software. At the conclusion of this step, each sky point has a pair of spherical coordinates and an insolation value. Insolation values may be expressed in any of the units available in GLA (e.g., moles photons/meter^2/day). The choice of insolation units does not matter in this context.
#'
#'> Step 3: Sum the insolation values of all sky points corresponding to each separate directional densiometer measurement.
#'
#'> Step 4: Compute the coefficients for weighted averaging. The coefficient for any single direction represents the fraction of total insolation which is contributed by sky points associated only with that single directional canopy densiometer measurement. For example, if a researcher is taking separate densiometer measurements facing N, E, S, and W from a point on the land surface, the coefficient for weighted averaging of the north-facing measurement will be equal to the sum of insolation values of all northern sky points divided by the sum of insolation values of all sky points. Coefficients will sum to 1.
#'
#' Note that steps 2, 3, and 4 can optionally be suppressed by setting argument weightscalc to FALSE. In this case, the only output of interest is a tibble containing spherical coordinates of sky points. Sky point coordinates can also be computed without passing a GLA detailed report to the function by keeping argument gla_detrep set as NA.
#'
#'-----------------------------------------------
#'
#'GAP LIGHT ANALYZER (EXTERNAL SOFTWARE INSTRUCTIONS)
#'
#'GLA is designed to estimate forest understory light environment by using global solar radiation models and hemispherical images of canopy coverage captured using a DSLR and a fisheye lens. In the context of the use of package canavg, GLA is being used to generate a detailed report which contains estimated insolation values as would be observed in the absence of forest canopy (i.e. values predicted by latitude and climatic parameters such as average cloud cover and atmospheric haziness).
#'
#'Use of this function for weighting coefficients calculation is dependent the user having previously used GLA to generate a detailed report containing estimates of insolation values for each of 4050 small sky regions at a user-defined latitude, over either a full year or a user-defined fraction of the year (i.e., the growing season), and with reference to either GLA default or user-defined climatic parameters which affect insolation values (atmospheric haziness, cloudiness, etc.). A detailed report can be generated by using GLA to analyze a blank .bmp file. When passing a blank .bmp file to GLA, no understory insolation values or canopy structure values provided in the detailed report will be meaningful. However, above-canopy insolation values will be meaningful. Instructions for how to generate a detailed report in GLA are provided below:
#'
#'> Step 1: Download Gap Light Analyzer 2.0 (link: https://www.caryinstitute.org/science/our-scientists/dr-charles-d-canham/gap-light-analyzer-gla).
#'
#'> Step 2: Open MS paint or a similar program and save a blank white image as a bitmap (.bmp) file.
#'
#'> Step 3: Open GLA.
#'
#'> Step 4: In GLA, open the empty bitmap that you generated in step 2 by clicking File on the menu bar, then Open Image.
#'
#'> Step 5: Click Configure on the menu bar, then click Edit Configuration. This opens the Configuration Settings dialog box.
#'
#'> Step 6: In the Configuration Settings dialog box, under the Site tab, input geographic coordinates and elevation of your study site. Do not modify defulat selections in the Orientation or Topographic Shading sections.
#'
#'> Step 7: In the Configuration Settings dialog box, under the Resolution tab, set the Number of Azimuth Regions to 90 and the Number of Zenith Regions to 45. Function canavg will not be able to parse the final report if this step is not carried out.
#'
#'> Step 8: In the Configuration Settings dialog box, under the Resolution tab, set the Growing Season Start Date and the Growing Season end date. These values may be either true growing season beginning and end dates or may be set to January 1st and December 31st, respectively, to estimate insolation over a full year. Leave Solar Time Step as 2 minutes.
#'
#'> Step 9: In the Configuration Settings dialog box, under the radiation tab, make any adjustments required to Model Parameters and Sky-Region Brightness. Choice of appropriate parameter values (Solar Constant, Cloudiness, Spectral Fraction, etc.) is highly location-dependent. This function documentation does not provide advice or recommendations regarding choice of values during this step. Please refer to GLA documentation at https://rem-main.rem.sfu.ca/downloads/Forestry/GLAV2UsersManual.pdf and local climate data for appropriate Model Parameter selection.
#'
#'> Step 10: Click Configure on the menu bar, then Register Image. Use the mouse to draw a registration circle over the bitmap. When using GLA as intended, this step is required to both define north within the photo and to remove areas of the image which are outside of the circular photograph area from analysis. Because you are not using a real photograph, how you register the image does not matter. Set the circle, then click Apply and then click Okay on the Image Registration dialog box.
#'
#'> Step 11: Click Image on the menu bar, then Threshold. Click OK on the Threshold dialog box that appears. When using GLA as intended, this step is required to categorize image pixels as either vegetation or sky. Because you are not using a real photograph, threshold value chosen during step does not matter.
#'
#'> Step 12: Click Calculate on the menu bar, then Run Calculations. On the Calculations dialog box which appears, ensure that option Log Details to File is checked - this is the option that indicates to GLA that it should generate the detailed report which you will pass to function canavg. When you check this option, a dialog box which allows you to choose a file location and name for the detailed report will appear. Choose the location and file name and press Save. On the Calculations dialog box, ensure that option Canopy Structure and Transmitted Gap Light is checked. Finally, click Calculate.
#'
#'> Step 13: Close GLA. The detailed report containing insolation values for each of 4050 sky regions will be found at the location and filename which you selected in step 12. This report will be passed to function canavg in R.
#'
#'-----------------------------------------------
#'
#'CONCAVE SPHERICAL CANOPY DENSIOMETER
#'
#'The canopy densiometer to which this package refers is the 'concave spherical crown densiometer' sold primarily by Forestry Suppliers (Jackson, Mississippi) and widely used by foresters and other field biologists (Manufacturer Parts Number: 43888). This package does not currently support computation of sky point spherical coordinates for the convex mirror densiometer (Manufacturer Parts Number: 43887).
#'
#'Product purchase link: https://www.forestry-suppliers.com/p/43888/13971/forestry-suppliers-spherical-crown-densiometers
#'
#'Instructions manual link: https://www.forestry-suppliers.com/Documents/4283_msds.pdf
#'
#'-----------------------------------------------
#'
#'ORIENTATION OF X, Y, Z AXES RELATIVE TO OBSERVER
#'
#'A three-dimensional model of the spherical densiometer mirror surface is created within function canavg to allow for computation of sky point spherical coordinates. When the densiometer is held with the mirror surface facing directly upwards, the three-dimensional space is arranged as follows:
#'
#'> The origin (X=0, Y=0, Z=0) is at the center of the imaginary sphere of which the physical mirror surface is a section. This sphere has a radius of 3 inches, so the origin is three inches above the center of the engraved grid on the mirror surface. The mirror surface is the bottom of this otherwise imaginary sphere.
#'
#'> The X and Y dimensions are parallel to the ground surface:
#'
#'>> The Y-axis extends to positive infinity in the direction that the observer is facing and to negative infinity behind them.
#'
#'>> The X-axis is perpendicular to the Y-axis and parallel to the ground surface, extending to positive infinity to the observer's right and to negative infinity to the observer's left.
#'
#'> The Z-axis extends to positive infinity above the observer and to negative infinity below them
#'
#'The observer's eye position is mapped in this this three-dimensional space, with a default X coordinate of 0, Y coordinate of -8, and Z coordinate of 10. It is recommended that you measure distances between your eye and the sphere's center to ensure that these defaults are appropriate.
#'
#' @description
#' @param gla_detrep Filepath as character string; Raw, unedited detailed report in .txt format generated by GLA. Default is NA.
#' @param eyey Integer (inches); Y-coordinate of the observer's eye. Default is -8.
#' @param eyez Integer (inches); Z-coordinate of the observer's eye. Default is +10.
#' @param survmeth Character string; Survey method. Only "card" is supported at this time. "Card," short for "cardinal directions", indicates that measurements were taken facing N, E, S, and W from any single point on the ground surface. Optionally, can be set to "rose" but associated functionality is still under development.
#' @param weightscalc Logical; If TRUE, computes weighting coefficients for averaging. Default is TRUE.
#' @param diagnostics Logical; if TRUE, prints three figures: (1) XYZ coordinates of all points in physical engraved grid on mirror surface (interactive figure); (2) insolation values by sky region as contained in Gap Light Analyzer detailed report; (3) and azimuth and altitude coordinates of all sky points. If you are executing function canavg many times automatically, as in a loop, set this to FALSE in order to avoid having many plots appearing on your screen. Default is TRUE.
#'
#' @return A list containing:
#' \describe{
#'   \item{direction_weights_vector}{Numeric vector of direction weighting coefficients. Will be NA if arguemnt gla_detrep or argument weightscalc are set to NA.}
#'   \item{full_points_data_tibble}{Tibble containing the full sky points data. Some columns will remain unpopulated if arguemnt gla_detrep or argument weightscalc are set to NA}
#'   \item{Raw_GLA_report}{Raw report data from the Gap Light Analyzer. Will be NA if no GLA detailed report is passed to function.}
#'   \item{README}{Character string noting whether or not a GLA detailed report was passed to the function and whether or not weighted averaging coefficients were calculated. Useful for bookkeeping when running the function multiple times with different argument settings.}
#' }
#' @export
#'
#' @examples
#' # Example usage of the canavg function
#' # Read in GLA detailed report. This report was generated at 45 N, over a full year, using all default parameter values.
#' # Note - this filepath is incomplete. You need to include the full filepath to your canavg directory.
#' my_report <- "extdata/45n_gladetrep.txt"
#' # Execute function canavg
#' canavg(gla_detrep = my_report, eyey = -8, eyez = 10, survmeth = "card", weightscalc = TRUE, diagnostics = TRUE)

canavg <- function(gla_detrep = NA, eyey=-8, eyez=10, survmeth = "card", weightscalc = TRUE,  diagnostics=TRUE) {

  if (is.na(gla_detrep) && weightscalc == TRUE) {
    stop("Error: 'gla_detrep' cannot be NA while 'weightscalc' is TRUE. Computation of weighting coefficients is fully reliant on access to a GLA report. If you are intending to execute this function without a GLA detailed report, ensure that argument 'weightscalc' is FALSE. If you have forgotten to pass a GLA detailed report to this function, do that now.")
  }

  if (survmeth == "rose") {
    stop("Error: 'rose' functionality is under development and is not supported at this time.")
  }

  if (eyey > 0) {
    stop("Error: Variable 'eyey' must be below or equal to zero. The observer is standing in the negative part of the Y dimension. Did you manually set the value of 'eyey' to a non-default value and forget a negative sign?")
  }

  ### Define constants and XY grid of points on mirror surface
  rad_to_deg_coeff <- 180 / pi    # Coefficient to convert radians to degrees
  deg_to_rad_coeff <- pi / 180    # Coefficient to convert degrees to radians
  r_sphere <- 3                   # Radius of sphere (inches), provided by mirror densiometer user manual
  c_sphere <- r_sphere * 2 * pi   # Circumference of sphere (inches)
  quarter_c_sphere <- c_sphere/4  # One quarter of the circumference (inches)

  if (survmeth == "card") {
    # name cardinal directions
    dirscomplete <- c("n","e","s","w")
    # X and Y coordinates of 96 engraved surface points, treating mirror surface as a flat plane w/o hemispherical shape
    eng_coords <- tibble::tibble(
      x_eng_vect = c(0.0625,0.1875,0.3125,0.4375,0.5625,0.6875,0.0625,0.1875,0.3125,0.4375,0.5625,0.6875,0.0625,0.1875,0.3125,0.4375,0.0625,0.1875,0.3125,0.4375,0.0625,0.1875,0.0625,0.1875,-0.0625,-0.1875,-0.3125,-0.4375,-0.5625,-0.6875,-0.0625,-0.1875,-0.3125,-0.4375,-0.5625,-0.6875,-0.0625,-0.1875,-0.3125,-0.4375,-0.0625,-0.1875,-0.3125,-0.4375,-0.0625,-0.1875,-0.0625,-0.1875,0.0625,0.1875,0.3125,0.4375,0.5625,0.6875,0.0625,0.1875,0.3125,0.4375,0.5625,0.6875,0.0625,0.1875,0.3125,0.4375,0.0625,0.1875,0.3125,0.4375,0.0625,0.1875,0.0625,0.1875,-0.0625,-0.1875,-0.3125,-0.4375,-0.5625,-0.6875,-0.0625,-0.1875,-0.3125,-0.4375,-0.5625,-0.6875,-0.0625,-0.1875,-0.3125,-0.4375,-0.0625,-0.1875,-0.3125,-0.4375,-0.0625,-0.1875,-0.0625,-0.1875),
      y_eng_vect = c(0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.3125,0.3125,0.3125,0.3125,0.4375,0.4375,0.4375,0.4375,0.5625,0.5625,0.6875,0.6875,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.3125,0.3125,0.3125,0.3125,0.4375,0.4375,0.4375,0.4375,0.5625,0.5625,0.6875,0.6875,-0.0625,-0.0625,-0.0625,-0.0625,-0.0625,-0.0625,-0.1875,-0.1875,-0.1875,-0.1875,-0.1875,-0.1875,-0.3125,-0.3125,-0.3125,-0.3125,-0.4375,-0.4375,-0.4375,-0.4375,-0.5625,-0.5625,-0.6875,-0.6875,-0.0625,-0.0625,-0.0625,-0.0625,-0.0625,-0.0625,-0.1875,-0.1875,-0.1875,-0.1875,-0.1875,-0.1875,-0.3125,-0.3125,-0.3125,-0.3125,-0.4375,-0.4375,-0.4375,-0.4375,-0.5625,-0.5625,-0.6875,-0.6875))
  } else if (survmeth == "rose") {
    dirscomplete <- c("n", "ne", "e", "se", "s", "sw", "w", "nw")
    x_eng_vect <- NA
    y_eng_vect <- NA
  } else if (survmeth != "card" & survmeth != "rose") {
    stop("Invalid value for argument 'survmeth'. Use 'card' or ose' only.")
  }

  ### Initialize output data frames
  # Tibble for XYZ coordinates of each of 96 points in physical engraved mirror surface grid
  # This tibble initialized empty - will be populated row-wise in for loop below
  out <- tibble(
    x_orgPlane = numeric(0),
    y_orgPlane = numeric(0),
    z_orgPlane = numeric(0),
    # point class grouping factor
    group = factor("mirror")
  )

  # Define 3-dimensional bounding box for later visualization
  # note - these values are not important for analysis, only setting bounds of 3D plot
  bound_box <- tibble(
    x_orgPlane = c(-3, -3, 3, 3, -3, -3, 3, 3),
    y_orgPlane = c(-3, 3, -3, 3, -3, 3, -3, 3),
    z_orgPlane = c(-3, -3, -3, -3, 3, 3, 3, 3),
    # point class grouping factor - this used solely for visualization
    group = factor("boundingbox")
  )

  # Define geometry for origin of 3D Cartesian space
  sphere_center_3d <- tibble(
    x_orgPlane = c(0),
    y_orgPlane = c(0),
    z_orgPlane = c(0),
    # point class grouping factor - this used solely for visualization
    group = factor("center")
  )

  ### compute XYZ coordinates n 3D space for each of 96 points on the mirror surface
  # note - anything called 'eng' or 'engraved' refers to the mirror surface w/ its engraved grid
  # note - this is not strictly necessary to re-compute with each call to this function. I have included these calculations in order to be transparent about the conversion process between the engraved grid and 3-dimensional space.
  for (i in seq_len(nrow(eng_coords))) {
    # pick row corresponding to
    x_engraved <- eng_coords[i,1]
    y_engraved <- eng_coords[i,2]

    # Step 1: Calculate X component of point on XY plane in XYZ coordinate system
    # calculate angle (radians) below XY plane of line w/ end points at origin and point's X value on engraved grid's X axis
    # here "negalt" indicates "negative altitude", or radians below horizon
    negalt_x <- ((90 - (x_engraved / (c_sphere / 4) * 90)) * -1) * deg_to_rad_coeff

    # Use known angle and hypotenuse length (3 in, radius of sphere) to calculate the X component of the point in XYZ space
    x_cartPlane <- cos(negalt_x) * r_sphere

    # Step 2: Calculate Y component of point on XY plane in XYZ coordinate system
    # calculate angle (radians) below XY plane of line w/ end points at origin and point's Y value on engraved grid's X axis
    # here "negalt" indicates "negative altitude", or radians below horizon
    negalt_y <- ((90 - (y_engraved / (c_sphere / 4) * 90)) * -1) * deg_to_rad_coeff
    # Use known angle and hypotenuse length (3 in, radius of sphere) to calculate the Y component of the point in XYZ space
    y_cartPlane <- cos(negalt_y) * r_sphere

    # Step 3: Calculate Z component of point in XYZ coordinate system
    # Calculate angle (radians) between line extending from origin to positive infinity on the XYZ Y axis and line with end points at origin and XY coordinates in XYZ space as calculated above
    az_ang_rad <- atan(x_cartPlane / y_cartPlane)
    # Calculate z value of sphere surface at XY point in XYZ space
    hyp <- sqrt(x_cartPlane^2 + y_cartPlane^2)
    z_cartPlane <- sqrt(r_sphere^2 - hyp^2) * -1

    # Store calculated values
    out[i,1] <- x_cartPlane
    out[i,2] <- y_cartPlane
    out[i,3] <- z_cartPlane
    # include string "mirror" to aid in later categorization and visualization
    out[i,4] <- "mirror"

    # When last iteration is ending, combine tibbles containing computed XYZ coordinates and bounding box and center coordinates
    if (i == nrow(eng_coords)) {
      combined_data <- na.omit(out) %>%
        bind_rows(bound_box) %>%
        bind_rows(sphere_center_3d)
    }
  }

  ### Compute slope and bearing of line reflecting off mirror surface emitted from eye
  # define point of light emission in XYZ space (eye position, with Y and X components defined in function call
  # note - these variables are given default values in function skypoints, but can be modified manually
  eye_position_xyz <- c(0, eyey, eyez)

  # Calculate plane tangent to sphere surface at each of 96 points
  # loop j is for stepping through each measurement direction
  for (j in 1:length(dirscomplete)) {
    if (j == 1) {
      # define empty list for storage of outputs
      list_out <- vector(mode='list', length=4)
      # code below defaults to E as azimuth 0, this corrects to appropriate cardinal direction correction such that due
      if (survmeth == "card") {
        correction <- c(-90,0,90,180)
      }
    }

    # note - i loop is nested within j loop
    # note - object out contains XYZ coordinates of 96 points
    for (i in 1:nrow(out)) {
      if (i == 1) {
        sphere_origin <- c(0, 0, 0)
        out2 <- out %>%
          mutate(azmAng = NA) %>%
          mutate(altAng = NA) %>%
          mutate(index = as.factor(dirscomplete[j])) %>%
          dplyr::select(index, everything())
      }

      # Define the points
      reflection_point <- out2[i,2:4] %>% unlist() %>% as.vector()

      # Calculate the incident vector
      incident_vector <- reflection_point - eye_position_xyz

      # Calculate the normal vector at the reflection point
      # Since the mirror is a concave spherical mirror, the normal vector is just the normalized reflection point vector
      normal_vector <- reflection_point / sqrt(sum(reflection_point^2))

      # Calculate the reflection vector
      reflection_vector <- incident_vector - 2 * sum(incident_vector * normal_vector) * normal_vector

      # Calculate the azimuthal angle relative to the X-axis
      azimuthal_angle <- atan2(reflection_vector[2], reflection_vector[1]) * (180 / pi)
      if (azimuthal_angle < 0) {azimuthal_angle <- azimuthal_angle + 180}
      azimuthal_angle2 <- azimuthal_angle + correction[j]
      if (azimuthal_angle2 < 0) {azimuthal_angle2 <- azimuthal_angle2 + 360}
      out2[i,"azmAng"] <- azimuthal_angle2

      # Calculate the altitude above the horizon
      altitude <- asin(reflection_vector[3] / sqrt(sum(reflection_vector^2))) * (180 / pi)
      out2[i,"altAng"] <- altitude
    }
    list_out[[j]] <- out2
    if (j == 4) {
      out3 <- bind_rows(list_out) %>%
        mutate(total_brightness = NA_real_)
    }
  }

  # if using canavg to calculate weighted avg coefficients
  if (weightscalc == TRUE) {
  ### read in + use report from Gap Light Analyzer --------------------------------------------------
  raw_data <- readLines(gla_detrep)
  column_names_t1 <-  strsplit(raw_data[2], ";")[[1]] %>% gsub(pattern = " ", replacement = "", x = .)
  column_names_t2 <-  strsplit(raw_data[3], ";")[[1]] %>% gsub(pattern = " ", replacement = "", x = .)
  column_names <- paste0(column_names_t1,column_names_t2)
  rm(raw_data,column_names_t1,column_names_t2)

  # read in and manipulate main report
  gla_report <- read.delim(gla_detrep, sep = ";", header = FALSE, skip = 2) %>%
    # convert to tibble
    as_tibble() %>%
    # remove top row, which was relict of early data cleaning
    slice(-1) %>%
    # set column names
    set_names(column_names) %>%
    # convert columns 2-last from character to numeric
    mutate(across(.cols = 2:last_col(), .fns = ~parse_number(as.character(.)))) %>%
    # compute azimuth and altitude bin maxima degrees from bin number
    mutate(AziDegMax = AziBin*(360/length(unique(AziBin)))) %>%
    mutate(AltDegMax = AltBin*(90/length(unique(AltBin))))  %>%
    # compute azimuth and altitude bin minima degrees from bin number
    mutate(AziDegMin = (AziBin-1)*(360/length(unique(AziBin)))) %>%
    mutate(AltDegMin = (AltBin-1)*(90/length(unique(AltBin)))) %>%
    # compute azimuth and altitude bin means degrees from bin number
    mutate(AziDegCenter = (AziDegMax + AziDegMin)/2 ) %>%
    mutate(AltDegCenter = (AltDegMax + AltDegMin)/2 ) %>%
    mutate(ATbA = AboveTotal/(TotalArea/0.000001))

  # if incorrect number of azimuth and altitude bands used, throw error
  if (length(unique(gla_report$AziBin)) != 90 | length(unique(gla_report$AltBin)) != 45) {
    stop("Insufficient number of azimuth or altitude bins. \nEnsure that GLA output is divided into exactly 90 azimuth bins and 45 altitude bins.\nYou will need to return to GLA, reconfigure the output, and re-run calculations there.")}

  # apply gla_report$ATbA values to out3 rows based on azimuth and altitude
  # note - this is the important densiometer-GLA calibration step! All prior to this is preparation.
  for (k in 1:nrow(out3)) {
    # pull out individual azimuth and altitude values and numbers
    mirrorptAzi <- as.vector(unlist(out3[k,6]))
    mirrorptAlt <- as.vector(unlist(out3[k,7]))

    # pick azimuth-altitude bin associated w/ each point and extract insolation value
    out3[k,8] <- gla_report %>%
      # for azimuth - pick the column of azimuth bins which contains the point
      filter(AziDegMax > mirrorptAzi & AziDegMin < mirrorptAzi) %>%
      # for altitude - pick the row within this column which contains the point - this yields a single azi-alt bin
      filter(AltDegMax > mirrorptAlt & AltDegMin < mirrorptAlt) %>%
      # extract insolation value
      dplyr::select(ATbA)
  }

  #
  for (p in 1:4) {
    if (p == 1) {
      dirTotals <- rep(NA,4)
      names(dirTotals) <- dirscomplete
    }
    dirTotals[p] <- out3 %>%
      filter(index == dirscomplete[p]) %>%
      dplyr::select(total_brightness) %>%
      sum()
  }

  ### print averaging weights and optionally print diagnostic plots ---------------------------------
  # compute weights
  dirWeights <- dirTotals/sum(dirTotals)

  # optionally display diagnostics
  if (diagnostics == TRUE) {
    # Generate 3D scatter plot for visual validation of geometry #
    car::scatter3d(
      y_orgPlane ~ x_orgPlane + z_orgPlane | group,
      data = combined_data,
      xlim = c(0, .2),
      ylim = c(0, 3),
      zlim = c(-3, 0),
      axis.ticks = TRUE,
      point.col = "black",
      sphere.size = 0.5,
      surface.alpha = 0,
      fogtype = "linear",
      residuals = FALSE
    )
    # Add main title
    rgl::title3d(main = "Mirror Surface Point in 3D Space", line = 2)
    # Add axis labels
    rgl::mtext3d(text = "X Axis (inches) - Perpindicular to Direction of View", edge = "x-", line = 3)
    rgl::mtext3d(text = "Y Axis (inches) - Parallel to Direction of View", edge = "y-", line = 3)
    rgl::mtext3d(text = "Z Axis (inches) - Normal Line to the Ground", edge = "z-", line = 3)

    # display sunlight contribution by each azimuth-altitude bin in arbitary unit
    gg1 <- ggplot2::ggplot(gla_report, aes(x = AziDegCenter, y = AltDegCenter, fill = ATbA)) +
      ggtitle("PAR Per 0.000001th Area of Sky Hemisphere") +
      geom_raster(alpha = 0.9) +  # Set raster transparency
      scale_fill_viridis_c() +  # Apply viridis color scale
      labs(
        x = "Azimuth\n(degrees clockwise from north)",
        y = "Altitude\n(degrees above horizon)",
        fill = "Legend\nUnits Determined\nin GLA",
        title = "Contribution of Sun by Azimuth-Altitude Bins"
      ) +
      scale_x_continuous(
        limits = c(0, 360),
        breaks = c(0,45, 90, 135, 180, 225, 270, 315, 360)
      ) +
      scale_y_continuous(
        limits = c(0, 90),
        breaks = c(0,15,30,45,60,75,90)
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(hjust = 0.5),
        panel.grid.major.x = element_line(color = "black", linewidth = 0.5),
        panel.grid.major.y = element_line(color = "black", linewidth = 0.5),
        panel.grid.minor = element_blank()  # Remove minor gridlines
      )
    print(gg1)

    # visualize sky points corresponding to 96 mirror surface points
    gg2<- ggplot2::ggplot(data = out3, aes(x = azmAng, y = altAng, color = factor(index))) +
      geom_point(shape = 19, size = 3) +  # Specify point shape
      scale_x_continuous(
        limits = c(0, 360),
        breaks = seq(0, 360, by = 45),
        name = "Azimuth\n(degrees clockwise from north)"  # X-axis label
      ) +
      scale_y_continuous(
        limits = c(0, 90),
        breaks = seq(0, 90, by = 15),
        name = "Altitude\n(degrees above horizon)"  # Y-axis label
      ) +
      labs(
        title = "Azimuth and altitude of each of 96 points in each of four cardinal directions",
        color = "Index"  # Legend title for color scale
      ) +
      theme_minimal() +
      theme(
        axis.text.x = element_text(angle = 90, hjust = 1),  # Rotate x-axis labels
        plot.title = element_text(hjust = 0.5),  # Center plot title
        legend.position = "none",  # Remove legend
        panel.grid.major = element_line(color = "black", size = 0.5),  # Black major gridlines
        panel.grid.minor = element_blank()  # Remove minor gridlines
      )
    print(gg2)
    }
  # define output list
  # list contains all mirror XYZ coordinates, azimuth and altitude of assoc. points in sky, and insolation values

    out4 <- out3 %>% dplyr::select(-group)

    output_full <- list(dirWeights,
                        out4,
                        gla_report,
                        "README: GLA detailed report passed to canavg, weights stored as output list [[1]]")

    names(output_full) <- c("direction_weights_vector","full_points_data_tibble","Raw GLA report","README")
  } else if (weightscalc == FALSE) {

    out4 <- out3 %>% dplyr::select(-group)
    dirWeights <- NA
    gla_report <- NA
    output_full <- list(dirWeights,
                        out4,
                        gla_report,
                        "README: No GLA detailed report passed to canavg, weights not calculated")

    names(output_full) <- c("direction_weights_vector","full_points_data_tibble","Raw GLA report","README")
  }
  return(output_full)
}
